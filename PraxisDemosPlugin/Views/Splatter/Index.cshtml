<html>
<head>
    @* Local resource links *@
    <link rel="stylesheet" href="~/Content/leaflet.css" />
    <script src="~/Content/Scripts/leaflet.js"></script>
    <script src="~/Content/Scripts/PlusCodes.js"></script>
</head>
<body>
    <div id="mapid" style="height:100%; z-index:20;">
    </div>
    <script type="text/javascript">
        //This is the Splatter web interface/toy. No login required. Things to do here:
        //list of colors you could select from the splatter palette.
        //Have clicks on the map trigger a splat effect in selected color
        //Load only mapTiles base layer, and only splatter overlay.
        //Use tilelayer.redraw on a timer to update all tiles, or check TileGen value to save bandwidth. May require adding random number or timestamp to tiles URL to avoid browser cache.
        var serverKey = "testingKey"; //TODO: lock this page to only localhost or find an alternate way to obfuscate this.
        var baseSite = window.location.href.toLowerCase().split("/splatter")[0];
        console.log(baseSite);
        var url = baseSite + '/{id}/{z}/{x}/{y}.png?PraxisAuthKey=' + serverKey;
        var baseData = L.tileLayer(url, { id: "MapTile/Slippy/mapTiles", tileSize: 512, maxZoom: 20, minZoom: 3, zoomOffset: -1 });
        var splatterData = L.tileLayer(url, { id: "Splatter/Slippy", tileSize: 512, maxZoom: 20, minZoom: 3, zoomOffset: -1 });
        var splatterTiles = [];
        var mymap = L.map('mapid');
        baseData.addTo(mymap);
        splatterData.addTo(mymap);
        var currentColorId = 0;

        var autoRefresh = setInterval(redraw, 15000);

        splatterData.on('tileload', function (ev) {
            console.log("LOAD:");
            if (ev.coord == null)
                return;
            splatterTiles[ev.coords.x + "|" + ev.coords.y + "|" + ev.coord.z] = ev.tile;
        });
        splatterData.on('tileunload', function (ev) {
            console.log("UNLOAD:");
            if (ev.coord == null)
                return;
            delete splatterTiles[ev.coords.x + "|" + ev.coords.y + "|" + ev.coord.z];
        });

        var startLat = 0;
        var startLon = 0;
        fetch(baseSite + "/Server/ServerBounds", { headers: { 'PraxisAuthKey': serverKey } })
            .then(b =>
                b.text().then(bb => {
                    var points = bb.split("|");
                    for (var i = 0; i < 4; i++)
                        points[i] = points[i] * 1; //quick conversion to numbers from strings.
                    startLat = points[0] + (points[2] - points[0]) / 2;  //south + (north - south) / 2
                    startLon = points[1] + (points[3] - points[1]) / 2; //west + (east - west) / 2
                    console.log("Starting point set to " + startLat + "," + startLon + " from data " + bb);
                    mymap.setView([startLat, startLon], 15);
                })
            );

        // let textbox = L.Control.extend({
        //     onAdd: function () {
        //         var text = L.DomUtil.create('input');
        //         text.id = "txtSearch";
        //         text.placeholder = "PlusCode";
        //         return text;
        //     },

        // });
        // new textbox({ position: 'topleft' }).addTo(mymap);

        // let searchBtn = L.Control.extend({
        //     onAdd: function () {
        //         var btn = L.DomUtil.create('button');
        //         btn.id = "info_btn";
        //         btn.innerHTML = "Jump!";
        //         btn.onclick = () => {
        //             var tb = document.getElementById("txtSearch");
        //             var coord = OpenLocationCode.decode(tb.value);
        //             console.log(coord);

        //             mymap.setView([coord.latitudeCenter, coord.longitudeCenter], coord.codeLength + 9);
        //         };
        //         return btn;
        //     },

        // });
        //new searchBtn({ position: 'topleft' }).addTo(mymap);

        //TODO: get splatter colors
        // fetch(baseSite + "/StyleData/json/splatter", { headers: { 'PraxisAuthKey': serverKey } })
        //     .then(s => s.json().then(ss => {
        //         //TODO: parse
        //         // let palette = L.Control.extend({
        //         //     onAdd: function () {
        //         //         var div = L.DomUtil.create('div');
        //         //     },
        //         // })
        //     });
            
        //         var paletteB = "<div id='palette'>";
        //         ss.paintOperations.forEach((p) => { 
        //             if (p.Name != "background") {
        //                 // add a swatch with p.HtmlColorCode to some palette control. use p.Name to handle index
        //                 //probably uses L.control.create to make a new div with the BG color set from the style, and an onclick to set currentColorId to that id.
        //             }
        //         });

        //         //palette += "</div>";
        // });

        mymap.on('click', function (mouseEvent) { 
            //console.log(JSON.stringify(mouseEvent));
            var plusCode = OpenLocationCode.encode(mouseEvent.latlng.lat, mouseEvent.latlng.lng);
            plusCode = plusCode.replace("+", "");
            console.log(plusCode);
            //now call splat. A Cell10 is about zoom 15.7, which is the radius of 1 on the game-side. 
            //var radius = (15.7 / mymap.getZoom()); 
            // //zoom15 == 1.05, 16 = 0.98, 20=.8, 2 = 7.98. This is probably too small when zoomed out. Needs an extra factor.
            var radius = (15.7 / mymap._zoom) * (mymap._layersMaxZoom - mymap._zoom);
            //1 * 5 = 5, 1 * 4 = 4, .8 * 2 = 1.6, 8 * 18 = 144. Seems better, will have to see in practice if thats sufficient.
            fetch(baseSite + "/Splatter/FreeSplat/" + plusCode + "/" + radius, { method:"PUT", headers: { 'PraxisAuthKey': serverKey } })
                .then(s => s.text().then(ss => { 
                    //todo: get new tile here. we clicked, we know this one needs updated. TileEvent.coords would have what i want, but i got a mouseEvent.
                    //May just refresh the whole layer? I could invalidate the individual tile with its x/y/z coords and the array. Maybe mouseEvent.target has it?
                    redraw();
                }));

        });

        //mymap.on('moveend', function () {
            // var center = mymap.getCenter();
            // var coord = OpenLocationCode.encode(center.lat, center.lng);
            // var tb = document.getElementById("txtSearch");
            // tb.value = coord;
        //});

        function redraw()
        {
            splatterData.setUrl(baseSite + '/Splatter/Slippy/{z}/{x}/{y}.png?PraxisAuthKey=' + serverKey + "&t=" + Date.now());
            splatterData.redraw();
        }

        function reloadOne(x, y, z) { 
            if (splatterTiles[x + "|" + y + "|" + z] != null)
            {
                splatterTiles[x + "|" + y + "|" + z].src += "&t=" + Date.now(); //TODO: may change this to reset value instead of appending a timestamp
            }
        }

    </script>
</body>
</html>